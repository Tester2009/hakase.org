<!DOCTYPE html>
<html lang=en>
<meta charset=utf-8>

<title>hakase.org</title>
<meta name=description content="Because it's cute!">

<link rel=icon href=favicon.ico>

<style>
  @font-face {
    font-family: 'Droid Serif';
    font-style: normal;
    font-weight: 400;
    src: local('Droid Serif'), local('DroidSerif'), url(https://hakase.org/droid.woff2) format('woff2');
  }

  html {
    min-height: 100%;
    background: url(bg.png), -moz-radial-gradient(center, ellipse cover, #fafafa 70%, #c6c6c6 100%); /* FF3.6+ */
    background: -url(bg.png), webkit-gradient(radial, center center, 0px, center center, 100%, color-stop(70%,#fafafa), color-stop(100%,#c6c6c6)); /* Chrome,Safari4+ */
    background: url(bg.png), -webkit-radial-gradient(center, ellipse cover, #fafafa 70%,#c6c6c6 100%); /* Chrome10+,Safari5.1+ */
    background: url(bg.png), -o-radial-gradient(center, ellipse cover, #fafafa 70%,#c6c6c6 100%); /* Opera 12+ */
    background: url(bg.png), -ms-radial-gradient(center, ellipse cover, #fafafa 70%,#c6c6c6 100%); /* IE10+ */
    background: url(bg.png), radial-gradient(ellipse at center, #fafafa 70%,#c6c6c6 100%); /* W3C */
  }

  html, body, h1 { margin: 0; padding: 0; }

  body {
    font-family: 'Droid Serif', serif;
  }

  #title {
    font-weight: 700;
    font-size: 150px;
    text-align: center;

    color: white;
    text-shadow: 3px 3px 0 black, 8px 8px 15px #aaa;

    margin: auto;
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
    height: 150px;

    z-index: 1;
  }

  /* the containing nav element is actually a fairly extensive hack to get the
  bottom-right counter-rounded corner to display _without_ making a scrollbar
  on the body, or having to set overflow-hidden on the html element itself,
  which prevents scrolling.  By having the nav containing element set to 100%
  of the page size, its own overflow: hidden can contain the tiny bottom-right
  #nav:after piece, giving us the effect we desire. so. cool.*/
  nav {
    margin: 0;
    padding: 0;

    position: absolute;
    top: 0;
    right: 0;
    width: 100%;
    height: 100%;

    overflow: hidden;
  }

  #nav {
    margin: 0;
    padding: 0 5px 0 5px;

    position: absolute;
    top: 0;
    right: 0;

    background: #222;
    border-bottom-left-radius: 5px;

    text-align: right;

    z-index: 11;
  }

  #nav:before {
    content: "";

    border-color: #222222;
    border-style: solid;
    border-top-right-radius: 10px;
    border-width: 5px 5px 0 0;

    height: 5px;
    width: 5px;

    position: absolute;
    left: -5px;
    top: -5px;
  }

  #nav:after {
    content: "";

    border-color: #222222;
    border-style: solid;
    border-top-right-radius: 10px;
    border-width: 5px 5px 0 0;

    height: 5px;
    width: 5px;

    position: absolute;
    bottom: -5px;
    right: -5px;
  }

  #nav li {
    display: inline;
    margin: 0;
    padding: 0;
  }

  #nav a {
    display: inline-block;
    height: 100%;
    padding: 0.5em;
    margin: 0;

    color: #ccc;
    text-decoration: none;
  }

  #nav a:hover {
    color: white;
  }

  #hakase {
    position: absolute;
    bottom: 0;
    z-index: 2;
  }

  section {
    visibility: hidden;
    margin: auto;
    position: absolute;
    top: 0;
    bottom: 0;

    width: 100%;
    min-width: 320px;
    height: 50%;

    z-index: 100;

    opacity: 0;

    pointer-events: none;
  }

  section > div {
    pointer-events: all; /* let return click through the sides */

    margin: 0 auto;
    width: 50%;
    min-width: 320px;
    height: 100%;
    padding: .5em;

    box-sizing: border-box;
    -ms-box-sizing: border-box;
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    -o-box-sizing: border-box;

    overflow-y: auto;
    background-color: rgba(240, 240, 240, 0.98);
    box-shadow: 0 0 15px 15px rgba(240, 240, 240, 0.98);
  }

  #return {
    opacity: 0;

    visibility: hidden;
    display: block;
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    right: 0;

    z-index: 10;
    background-color: rgba(0,0,0,0.15);
  }

  /* really clever way to click out of lightboxes, if I do say so myself */
  section:target, section:target ~ #return {
    visibility: visible;
    opacity: 1;
  }

  section, #return {
    transition: 1s;
    -moz-transition: 1s;
    -ms-transition: 1s;
    -webkit-transition: 1s;
    -o-transition: 1s;
  }

  p {
    line-height: 1.6em; /* TODO actual vertical rhythm */
  }
</style>

<meta name=viewport content="width=device-width, initial-scale=1">

<h1 id=title>hakase.org</h1>

<nav>
  <ul id=nav> <!-- see note in CSS about why there's a container -->
    <li><a href=#news>News
    </a></li><li><a href=#projects>Projects
    </a></li><li><a href=#about>About</a></li>
  </ul> <!-- ^ nonstandard linebreaks prevent whitespace between elements -->
</nav>

<section id=news><div>
  <h1>News</h1>
  <p>Wow, I'm so productive! Check out these various <a href=https://github.com/qqueue/fountain>fountain</a> consumables:
  <ul>
    <li><a href=http://fountain.hakase.org/demo/spess.html#a>a reason to use 3D CSS transforms, Valvrave-style.</a>
    <li><a href=https://github.com/qqueue/ANSICHAN>Terminal emulator rice, 4chan-flavored.</a>
    <li><a href=http://kibana.hakase.org/#/dashboard/elasticsearch/a>/a/ data exploration, through elasticsearch.</a>
  </ul>
</div></section>

<section id=projects><div>
  <h1>Projects</h1>
  <ul>
    <li><strong><a href=https://github.com/qqueue/c4>c4</a></strong> (formerly called html5chan),
        a 4chan userscript (of the future).
    <li><strong><a href=https://github.com/qqueue/fountain>fountain</a></strong>, a streaming API
        for 4chan.
  </ul>
</div></section>

<section id=about><div>
  <h1>About</h1>
  <p>A website, in your browser! How novel!
  <p><i>hakase.org</i> is designed and maintained by <a
      href=mailto:queue@hakase.org>queue</a>. You can stare at this
    website's source code on <a
      href=https://github.com/qqueue/hakase.org>Github</a> if you want.
</div></section>

<a id=return href=#></a>

<canvas id=hakase height=119>hakase.org</canvas>

<script>
(function () {
"use strict"

// stretch title stuff
// adapted from https://github.com/davatron5000/FitText.js

function debounce(time, fn) {
  var timeout
  return function () {
    var ctx = this, args = arguments
    clearTimeout(timeout)
    timeout = setTimeout(function () {
      fn.apply(ctx, args)
    }, time)
  }
}

// behold my carefully tuned constants
function resize() {
  var h1 = document.getElementById('title')
  h1.style.fontSize = (window.innerWidth / 7) + 'px'
  h1.style.height = (window.innerWidth / 5) + 'px'
}

document.addEventListener('DOMContentLoaded', function () {
  resize()
  window.addEventListener('resize', debounce(300, resize))
});

// page visibility API polyfill
if (!('hidden' in document)) {
  (function () {
    var prefix           = 'mozHidden' in document    ? 'moz'
                         : 'msHidden' in document     ? 'ms'
                         : 'webkitHidden' in document ? 'webkit'
                         : ''
      , hidden           = prefix + 'Hidden'
      , visibilityChange = prefix + 'visibilitychange'

    // set the real property, and dispatch the polyfilled event
    document.addEventListener(visibilityChange, function () {
      document.hidden = document[hidden]
      document.dispatchEvent(new CustomEvent("visibilitychange"))
    })
  }())
}

// The parts of the animation overlap slightly, so this is the true width
// to shift the container by when moving
var TURN_WIDTH_LEFT = 55
  , TURN_WIDTH_RIGHT = 170
  , WALK_LEFT_START = 266
  , WALK_RIGHT_START = 150
  , WALK_WIDTH = { left: [-27, -32, -19, -22, -25]
                 , right: [27, 32, 19, 22, 25]
                 }

document.addEventListener('DOMContentLoaded', function () {

  var hakase = document.getElementById('hakase')
    , ctx    = hakase.getContext('2d')

      // start animation after all the images load
    , total_assets = 5 + 5 + 14 + 16
    , onload = function () { if (--total_assets === 0) { tick() } }
    // aggressive compression of asset loading
    , assets = function (path, nl, nr) {
        var l = [], r = [], i
        for (i = 0; i < nl; ++i) {
          l[i] = new Image
          l[i].src = path + '/left/' + i + '.png'
          l[i].onload = onload
        }
        for (i = 0; i < nr; ++i) {
          r[i] = new Image
          r[i].src = path + '/right/' + i + '.png'
          r[i].onload = onload
        }
        return { left: l, right: r }
      }
    , walk      = assets("walk", 5, 5)
    , turn      = assets("turn", 14, 16)
    , x         = -250 // cutely walk into the screen from stage left
    , walking   = true
    , direction = "right"
    , anim      = walk[direction]
    , frames    = anim.length
    , frame     = 0

  function draw() {
    // resetting the canvas width has the added effect of clearing it
    hakase.width = document.documentElement.clientWidth

    // not all the images are the same height, and it's a goddamn hassle to
    // either figure out how to script them to the same height, or to do it
    // manually with GIMP's god-awful interface
    ctx.drawImage(anim[frame], x, 119 - anim[frame].height)
  }

  // animation loop
  function tick() {
    var width = document.documentElement.clientWidth // minus scrollbars

    ++frame

    if (walking) {
      frame = frame % frames

      x += WALK_WIDTH[direction][frame]

      if ( direction === "right" && (width - x) < TURN_WIDTH_RIGHT ||
           direction === "left" && x < TURN_WIDTH_LEFT ) {

        walking = false
        if (direction === "right") {
          direction = "left"
          x = width - 266 // width of actual turning anim
        } else { // left
          direction = "right"
          x = 0
        }

        anim = turn[direction]
        frames = anim.length
        frame = 0
      }
    } else { // turning
      if (frame >= frames) {
        walking = true
        anim = walk[direction]
        frames = anim.length
        frame = 0

        x = direction === "right" ? WALK_RIGHT_START : width - WALK_LEFT_START
      }
    }

    draw()

    if (document.hidden) {
      // continue once we're no longer hidden
      document.addEventListener("visibilitychange", function restart() {
        setTimeout(tick, 120)
        document.removeEventListener("visibilitychange", restart)
      })
    } else {
      setTimeout(tick, 120)
    }
  }
})
}())
</script>

